Ejercicio 5

proc ordenarFrecuencia(inout arr: Array) { // n = claves del diccionario d; m = longitud del array arr;
    d = new DiccLog<int,int> // O(1)
    for(int i = 0; i < arr; i++) { // Como n ≤ m => O(log(m))
        if (d.esta(arr[i])) {
            frecuencia_anterior := d.obtener(arr[i]); // O(log(n)) 
            d.definir(arr[i],frecuencia_anterior+1); // O(log(n))
        } else {
            d.definir(arr[i],0);
        }
    }

    A = new Array[d.tamaño]; // O(1)
    i = 0;
    for(k in d) { // O(n)
        A[i] = k;
    }

    A.mergeSort(); //O(n*log(n)) & n ≤ m => O(m*log(m)) Ordenamos por valor   
    A.mergeSortAux(); // O(n*log(n)) & n ≤ m => O(m*log(m)) Ordenamos por frecuencia

    i = 0;
    k = 0;
    while(i < arr.length) { // O(m)*O(log(n)) & n ≤ m => O(m)*O(log(m)) = O(m*log(m))
        j = 0;
        frec := d.obtener(arr[i]); O(log(n)),
        while (j < frec) { // O(frec)
            arr[i+j] := A[k];
            j++
        }
        k++;
        i =j
    }
} // O(m*log(m))

--------------------

Ejercicio 6

Idea:
Armo un array de triplas, que tenga la cantidad de secuencias de escaleras del array dado.
En la primera posición guardo la longitud del mismo, en la segunda guardo el primer elemento del array, en la tercera la posicion del primer elemento de la escalera.

Por ejemplo, para <5,6,8,9,10,7,8,9,20,15> Tenemos 5 escaleras, entonces nos queda armado así:
<<2,5,1,<3,8,2,<3,7,5>,<1,20,8>,<1,15,9>>

Luego ordenamos primero por la longitud (o sea el primero de la tripla), luego por el segundo elemento que es el primero de cada escalera. 

Por último rearmamos el array teniendo los cuidados necesarios.

Algoritmo

proc ordenarEscaleras(inout arr: Array<int>) {
    i = 0;
    datos_escaleras := new vectorVacío();
    while (i < arr.length) {
        j := i;
        prim := i;
        ultimo := i;
        while (j < arr.length -1 & arr[j] == arr[j+1]){
            ultimo := j;
            j++;
        }
        dato := new Tripla(ultimo+1-prim,i,arr[i]);
        datos_escaleras.agregarAtrás(dato);
        i := j;
    }

    datos_escaleras.mergeSort(); //ordeno por el primero que es la longitud... Puedo asumir que existe la función de MergeSort para un vector???
    datos_escaleras.mergeSortAux(); // ordeno por el segundo que es el menor elemento de la escalera

    nuevo := new Array(arr.length);
    i := 0;
    k := 0;
    while (i < datos_escaleras.longitud) {
        j = 0;
        tripla = datos_escaleras[i]
        while (j < tripla[1]) {
            l = tripla[3]
            nuevo[k] = arr[l];
            l++;
            k++;
            j++;
        } 
        i++;
    }
}

Las operaciones más complejas son los MergeSort, o sea que es O(n*log(n));

Ejercicio 9

(1) Vamos a armar un array de F y otro de M, los vamos a ordenar por nota (los ordenamos haciendo bucket sort), luego los concatenamos...

proc ordenaPlanilla(inout p: planilla) {
    por_notas_mujeres := new Array<ListaEnlazada<Alumno>>(11); // creo un array de 10 posiciones pues las notas van del 0 al 10
    por_notas_hombres := new Array<ListaEnlazada<Alumno>>(11);
    for(int i = 0; i < planilla.length; i++) { // O(p.length)
        nota := planilla[i].nota;
        genero := planilla[i].genero
        if (genero == fem) {
            por_notas_mujeres[nota].agregarAtrás(planilla[i]);
        } else {
            por_notas_hombres[nota].agregarAtrás(planilla[i]);
        }
    }

    i := 0;
    k := 0; //obs: este k es el que va a ir iterando sobre la planilla original, es necesario notar que nunca va a pasarse de rango, 
    while(i <= 10) {  // porque recorremos en por_notas_mujeres y en por_notas_hombres la misma cantidad de elementos que tiene planilla
        while (!por_notas_mujeres[i].vacia) {
            alumna := por_notas_mujeres[i].primero() //O(1)
            por_notas_mujeres := por_notas_mujeres[i].fin; //O(1)
            p[k] := alumna; //O(1)
            k++;
        }
        i++;
    }

    while(i <= 10) {
        while (!por_notas_hombres[i].vacia) {
            alumna := por_notas_hombres[i].primero()
            por_notas_hombres := por_notas_hombres[i].fin;
            p[k] := alumna;
            k++;
        }
        i++;
    }

}

(2) Ya no tendramos por_notas_hombres ni por_notas_mujeres, tendríamos un array de arrays de listas enlazadas, llamemoslo por_notas 
Entonces en por_notas[i] tenemos los elementos del tipo enum i (o sea, los del tipo enum recuerdo que a cada uno le corresponde un numero depende el orden que tengan)
En por_notas[i][j] tenemos la lista enlazada de todos los alumnos de tipo enum i que tienen nota j
El primer while no tendría el if que le había incluido
Los dos últimos whiles terminarían siendo uno externo que recorra los distintos tipos enum que hay, y un while interno muy similar al que ya había armado (el de 
while(i <= 10))

(3)Estos algoritmos, que son algortimo tipo BucketSort (aun más, se llama este algoritmo del cartero https://es.wikipedia.org/wiki/Ordenamiento_por_casilleros) trabaja 
bajo la premisa que los elementos del array se ordenan por las categorías que representan y que dichas categorías están acotadas. Por eso no resulta contradictorio con el
teorema de Lower Bound, que no asume premisas sobre el array a ordenar
En el primer caso, como sabíamos que los géneros están acotados por 2 y las notas por 10, queda complejidad O(n)
En el segundo caso, si el tipo enum genero es c, queda complejidad ¿¿O(n + c) u O(n*c)??
