TADs

#1 

TAD Coord es struct<x:float,y:float>

TAD Rectangulo {
    obs vertices: seq<Coord>

    proc crear(in s: seq<Coord>) : Rectangulo
        requiere {rectangulizable(s)}
        asegura  {res.vertices == s}
    
    proc rotar(inout r: Rectangulo, in angulo: float)
        requiere {0 â‰¤ angulo < 2*pi}
        asegura {rotado(old(r).vertices,r.vertices,angulo)}

    proc trasladar(inout r: Rectangulo, in deltaX: float, in deltaY: float)
        asegura  {trasladado(old(r).vertices,r.vertices,deltaX,deltaY)}

    proc escalar(inout r: Rectangulo, in e: int) //mucho lio, no thanks
        requiere {e > 0}
        asegura  {} 
    
    pred rectangulizable(in s: seq<Coord>){
        (âˆƒ a,b,c,d: Coord)(a âˆˆ s âˆ§ b âˆˆ s âˆ§ c âˆˆ s âˆ§ d âˆˆ s âˆ§L
                            âˆ§L prodPunto(a-b,c-d))
    }

    pred rotado(sinRotar: seq<Coord>, rotado: seq<Coord>, angulo: float){
        (âˆ€ b:Coord)(b âˆˆ sinRotar â‡’L (âˆƒ c:Coord)(c âˆˆ rotado âˆ§L rotar(b,angulo) = c))
    }

    aux -(a: Coord, b: Coord) : Coord 
        <a.x-b.x,a.y-b.y>

    aux prodPunto(a: Coord, b: Coord) : float 
        a.x*b.x + a.y*b.y;

    aux rotar(v: Coord, ang: float) : Coord 
        <norma(v)*cos(ang+theta(v)),norma(v)*sen(ang+theta(v))>;

    aux norma(v: Coord) : float = sqrt(v.x*v.x+v.y*v.y)

    aux theta(v: Coord) : float = safearctan(v);

    aux safearctan(v: Coord) : float 
        if v.x == 0 then ğ…/2*signo(v.y)else arctan(v.y/v.x);
    
    pred trasladado(sinTrasladar: seq<Coord>, trasladado: seq<Coord>, deltaX: float, deltaY: float){
        (âˆ€ v: Coord)(v âˆˆ sinTrasladar â‡’L (âˆƒ w: Coord)(w âˆˆ trasladado âˆ§L v.y + deltaY = w.y âˆ§ v.x + deltaX = w.x))
    }
}

TAD Punto3D es tupla<Z,Z,Z>

TAD Esfera {
    obs centro: Punto3D
    obs radio: âˆˆt

    proc crear(in centro: Punto3D, in radio: int) : Esfera
        requiere {radio > 0}
        asegura  {res.centro == centro âˆ§ res.radio == radio}
    
    proc rotar(inout r: Esfera)
        asegura  {r.centro == old(r).centro âˆ§ r.radio == old(r).radio}

    proc trasladar(inout r: Esfera, in c: Punto3D)
        asegura  {r.centro == c âˆ§ r.radio == old(r).radio}

    proc escalar(inout r: Esfera, in e: int)
        requiere {e > 0}
        asegura  {r.centro == old(r).centro}
        asegura  {r.radio == old(r).radio * e}  
}

#2

TAD Multiconjunto<T> {
    obs elems: conj<T x Z>

    proc vacia() : Multiconjunto<T>
        asegura  {res.elems == {}}

    proc agregar(inout m: Multiconjunto<T>, in e: T)
        asegura  {agregaElemento(m.elems,old(m).elems,e)}
        asegura  {mantieneRestantes(m.elems,old(m).elems,e)}

    proc quitar(inout m: Multiconjunto<T>, in e: T)
        requiere {pertenece(m.elems,e)}
        asegura  {quitaElemento(m.elems,e)}
        asegura  {mantieneRestantes(m.elems,old(m).elems,e)}

    proc cardinal(in m: Multiconjunto<T>) : Z
        asegura  {cardinal(m.elems) == res}

    proc apariciones(in m: Multiconjunto<T>, in e: T) : Z
        requiere {pertenece(m.elems,e)}
        asegura  {apariciones(m.elems,e,res)}

    pred agregaElemento(nuevo: conj<T x Z>, viejo: conj<T x Z> , e: T) {
        (âˆ€ t: <T x Z>)(t âˆˆ viejo âˆ§L t[0] != e â‡’ 
            â‡’ (âˆƒ tup: <T x Z>)(tup[0] == e âˆ§ tup[1] == 1 âˆ§ tup âˆˆ nuevo))
        âˆ¨
        (âˆƒ i: Z)(i > 1 âˆ§ <e,i> âˆˆ viejo â‡’ 
            â‡’ (âˆƒ t: <T x Z>)(t[0] == e âˆ§ âˆ§ t[1] = i + 1  t âˆˆ nuevo))
    }

    pred mantieneRestantes(nuevo: conj<T x Z>, viejo: conj<T x Z> , e: T) {
        (âˆ€ t: <T x Z>)(t[0] != e â‡’ 
            â‡’ (t âˆˆ nuevo â†” t âˆˆ viejo))
    }

    pred pertenece(c: conj<T x Z>, e: T) {
        (âˆƒ t: <T x Z>)(t âˆˆ c âˆ§ t[0] == e âˆ§ t[1] > 1)
    }
    
    pred quitaElemento(nuevo: conj<T x Z>, viejo: conj<T x Z> , e: T) {
        (âˆƒ i: Z)(i > 1 âˆ§ <e,i> âˆˆ viejo â‡’ 
            â‡’ (âˆƒ t: <T x Z>)(t âˆˆ nuevo âˆ§ t[0] == e âˆ§ t[1] = i-1))
        âˆ¨
        (âˆƒ i: Z)(i = 1 âˆ§ <e,i> âˆˆ viejo â‡’ 
            â‡’ !(âˆƒ t: <T x Z>)(t âˆˆ nuevo âˆ§ t[0] == e ))
    }

    aux cardinal(in m: conj<T x Z>) : Z =
        sum t: <T x Z> :: (t âˆˆ m) :: t[1]

    pred apariciones(m: conj<T x Z>, e: T, r: Z) {
        (âˆƒ t: <T x Z>)(t âˆˆ m âˆ§ t[0] = e âˆ§ t[1] = r)
    }
}

TAD Multidict<K,V> { //hacer
    obs elems: conj<K,conj<V>>

    proc vacia() : Multidict<K,V>
        asegura  {res.elems == {}}

    proc definir(inout m: Multidict<K,V>, in k: K, in v: V) //Definimos
        asegura  {defineClave(m.elems,old(m).elems,k,v)}
        asegura  {mantieneRestantes(m.elems,old(m).elems,k,v)}

    proc borrar(inout m: Multidict<K,V>, in k: K, in v: V)
        requiere {pertenece(m.elems,e)}
        asegura  {borraClave(m.elems,e)}
        asegura  {mantieneRestantes(m.elems,old(m).elems,e)}

    proc cardinal(in m: Multidict<K,V>) : Z
        asegura  {car âˆˆal(m.elems) == res}

    proc apariciones(in m: Multidict<K,V>, in e: T) : Z
        requiere {pertenece(m.elems,e)}
        asegura  {apariciones(m.elems,e,res)}

    pred defineClave(nuevo: conj<K,conj<V>>, viejo: conj<K,conj<V>> , e: T) {
        (âˆ€ t: <T x Z>)(t âˆˆ viejo âˆ§L t[0] != e â‡’ 
            â‡’ (âˆƒ tup: <T x Z>)(tup[0] == e âˆ§ tup[1] == 1 âˆ§ tup âˆˆ nuevo))
        âˆ¨
        (âˆƒ i: Z)(i > 1 âˆ§ <e,i> âˆˆ viejo â‡’ 
            â‡’ (âˆƒ t: <T x Z>)(t[0] == e âˆ§ âˆ§ t[1] = i + 1  t âˆˆ nuevo))
    }

    pred mantieneRestantes(nuevo: conj<K,conj<V>>, viejo: conj<K,conj<V>> , e: T) {
        (âˆ€ t: <T x Z>)(t[0] != e â‡’ 
            â‡’ (t âˆˆ nuevo â†” t âˆˆ viejo))
    }

    pred pertenece(c: conj<K,conj<V>>, e: T) {
        (âˆƒ t: <T x Z>)(t âˆˆ c âˆ§ t[0] == e âˆ§ t[1] > 1)
    }
    
    pred borraClave(nuevo: conj<K,conj<V>>, viejo: conj<K,conj<V>> , e: T) {
        (âˆƒ i: Z)(i > 1 âˆ§ <e,i> âˆˆ viejo â‡’ 
            â‡’ (âˆƒ t: <T x Z>)(t âˆˆ nuevo âˆ§ t[0] == e âˆ§ t[1] = i-1))
        âˆ¨
        (âˆƒ i: Z)(i = 1 âˆ§ <e,i> âˆˆ viejo â‡’ 
            â‡’ !(âˆƒ t: <T x Z>)(t âˆˆ nuevo âˆ§ t[0] == e ))
    }

    aux cardinal(in m: conj<K,conj<V>>) : Z =
        sum t: <T x Z> :: (t âˆˆ m) :: t[1]

    pred apariciones(m: conj<K,conj<V>>, e: T, r: Z) {
        (âˆƒ t: <T x Z>)(t âˆˆ m âˆ§ t[0] = e âˆ§ t[1] = r)
    }
}

#3 // Preguntar si modelan bien
TAD TTLcache<T> { 
    obs memoria: conj<T x float>
    obs limiteDeMemoria: int

    proc crear(in i: int) : TTLcache<T>
        asegura  {res.memoria == {}}
        asegura  {res.limiteDeMemoria == i}

    proc almacenar(inout c: TTLcache<T>, in e: T)
        requiere {|c.memoria| < c.limiteDeMemoria}
        asegura  {c.memoria - <e,0> == old(c).memoria}
    
    proc eliminar(inout c: TTLcache<T>)
        requiere {(âˆƒ t:<T x int>)(t âˆˆ c.memoria âˆ§ now() == t[2])}
        asegura  {(âˆ€ t:<T x int>)(t âˆˆ old(c).memoria âˆ§ now(t) == c.edv â‡’L old(c).memoria - {t} = c.memoria)}
}

TAD FIFOcache<T>{
    obs memoria: seq<T>
    obs limiteDeMemoria: int

    proc crear(in i: int) : FIFOcache<T>
        asegura  {res.memoria == []}
        asegura  {res.limiteDeMemoria == i}

    proc almacenar(inout c: FIFOcache<T>, in e: T)
        requiere {|c.memoria| < c.limiteDeMemoria}
        asegura  {c.memoria - e == old(c).memoria}
    
    proc eliminar(inout c: FIFOcache<T>)
        requiere {|c.memoria| == c.limiteDeMemoria}
        asegura  {c.memoria == subseq(old(c).memoria,1,|old(c).memoria|)}
        asegura  {c.limiteDeMemoria == old(c).limiteDeMemoria - 1}
}

TAD LRUcache<K> {
    obs memoria: dict<K,int>
    obs limiteDeMemoria: int

    proc crear(in i: int) : LRUcache<K>
        asegura  {res.memoria == {}}
        asegura  {res.limiteDeMemoria == i}

    proc almacenar(inout c: LRUcache<K>, in e: K)
        requiere {|c.memoria| < c.limiteDeMemoria}
        asegura  {c.memoria - e == old(c).memoria}
    
    proc eliminar(inout c: LRUcache<K>)
        requiere {|c.memoria| == c.limiteDeMemoria}
        asegura  {(âˆ€ k : K)(k âˆˆ old(c).memoria â‡’L 
                    (âˆƒ c : K)(c âˆˆ old(c).memoria âˆ§ c â‰  k âˆ¨L old(c).memoria[c] >= old(c).memoria[k]) â‡’L
                        delKey(old(c).memoria,c) == c.memoria)}
}
#4 

TAD Pila<T> {
    obs stack: dict<int,T>

    proc vacia() : Pila<T>
        asegura  {res.stack == {}}

    proc push(inout p : Pila<T>, in t: T)
        asegura  {|old(p.stack)| + 1 == |p.stack|}
        asegura  {|p.stack| âˆˆ p.stack âˆ§L p.stack[|p.stack|] = t}

    proc pop(inout p : Pila<T>)
        requiere {|p.stack| > 0}
        asegura  {|old(p.stack)| - 1 == |p.stack|}
        asegura  {Â¬(|p.stack| + 1 âˆˆ p.stack)}
    
    proc altura(in p: Pila<T>) : int
        asegura  {|p.stack| == res}
}

TAD Diccionario<K,V> {
    obs elems: conj<K x V>

    proc vacia() : Multiconjunto<T>
        asegura  {res.elems == {}}

    proc definir(inout m: Multiconjunto<T>, in k: K, in v: V)
        requiere {Â¬definido(m.elems,k,v)}
        asegura  {definido(m.elems,k,v)}
        asegura  {mantieneRestantes(m.elems,old(m).elems,k,v)}

    proc borrar(inout m: Multiconjunto<T>, in k: K, in v: V)
        requiere {definido(m.elems,k,v)}
        asegura  {Â¬definido(m.elems,k,v)}
        asegura  {mantieneRestantes(m.elems,old(m).elems,k,v)}

    proc tamaÃ±o(in m: Multiconjunto<T>) : Z
        asegura  {|m.elems| == res}

    proc valor(in m: Multiconjunto<T>, in k: K) : V
        requiere {definido(m.elems,k)}
        asegura  {m.elems[k] = res}

    pred definido(d: conj<K x V>, k: K, v: V) {
        k âˆˆ d âˆ§ d[k] = v
    }

    pred mantieneRestantes(nuevo: conj<K x V>, viejo: conj<K x V>, k: K, v: V) {
        (âˆ€ t: K)(t != k â‡’ 
            â‡’ ((t âˆˆ nuevo â†” t âˆˆ viejo) âˆ§ (nuevo[t] = viejo[t])))
    }
}

TAD Punto {
    obs rho: float
    obs theta: float

    proc nuevoPunto(in r: float, in t: float) : nuevoPunto
        requiere {rho > 0 âˆ§ 0 â‰¤ theta < 2*pi}
        asegura  {res.rho = r âˆ§ res.theta = t}
    
    proc coordRho(in p: Punto) : float
        asegura  {res = p.rho}

    proc coordTheta(in p: Punto) : float
        asegura  {res = p.theta}

    proc coordX(in p: Punto) : float
        asegura  {res = rho*cos(theta)}

    proc coordY(in p: Punto) : float
        asegura  {res = rho*sen(theta)}
    
    proc mover(inout p: Punto, in escalar: float, in angulo: float)
        requiere {escalar â‰¥ 0 âˆ§ 0 â‰¤ angulo < 2*pi}
        asegura  {p.radio = old(p)*escalar âˆ§ p.angulo = angulo}
}

#5 
TAD Coord es struct<x:int,y:int> 

TAD Robot {
    obs recorrido: Multiconjunto<Coord>
    obs actual: Coord

    proc arriba(inout r: Robot)
        asegura  {r.actual.y = old(r).actual.y + 1}
        asegura  {Las demas cosas se mantienen iguales}
        asegura  {agregaElemento(r.recorrido,old(r).recorrido,r.actual)}
        asegura  {mantieneRestantes(r.recorrido,old(r).recorrido,r.actual)}
        
    proc abajo(inout r: Robot) 
        asegura  {r.actual.y = old(r).actual.y - 1}
        asegura  {Las demas cosas se mantienen iguales}
        asegura  {agregaElemento(r.recorrido,old(r).recorrido,r.actual)}
        asegura  {mantieneRestantes(r.recorrido,old(r).recorrido,r.actual)}

    proc izquierda(inout r: Robot) 
        asegura  {r.actual.x = old(r).actual.x - 1}
        asegura  {Las demas cosas se mantienen iguales}
        asegura  {agregaElemento(r.recorrido,old(r).recorrido,r.actual)}
        asegura  {mantieneRestantes(r.recorrido,old(r).recorrido,r.actual)}

    proc derecha(inout r: Robot) 
        asegura  {r.actual.x = old(r).actual.x + 1}
        asegura  {Las demas cosas se mantienen iguales}
        asegura  {agregaElemento(r.recorrido,old(r).recorrido,r.actual)}
        asegura  {mantieneRestantes(r.recorrido,old(r).recorrido,r.actual)}

    proc masDerecha(in r: Robot) : Coord 
        asegura  {res âˆˆ r.recorrido âˆ§ (âˆ€ c: Coord)(pertenece(r.recorrido,c) â‡’L (res.x â‰¥ c.x))}

    proc cuantasVecesPaso(in r: Robot, in c: Coord) : int 
        asegura  {res = apariciones(r.recorrido,c,r)}
} // Preguntar porque no me cierra el uso de otro TAD

TAD Producto es String 

TAD Stock { 
    obs minimo: dict(Producto,int)
    obs comprados: dict(Producto,int)
    obs vendidos: dict(Producto,int)
    obs sustituto: dict(Producto,Producto x int) 

    proc crear() : Stock
        asegura  {res.minimo = {}}
        asegura  {res.comprados = {}}
        asegura  {res.vendidos = {}}
        asegura  {res.sustituto = {}}

    proc registrarProducto(inout s: Stock, in p: Producto, in m: int)
        requiere {Â¬p âˆˆ s.minimo}
        asegura  {p âˆˆ s.minimo âˆ§L s.minimo[p] == m}
        asegura  {comprados y vendidos permanecen iguales}

    proc comprar(inout s: Stock, in p: Producto, in c: int)
        requiere {p âˆˆ s.minimo âˆ§ cantDisponibles(p,s) + c > minimo} // Que la compra supera el minimo
        asegura  {setKey(old(s).comprados,p,old(s).comprados[p]+c) == s.comprados}
        asegura  {El resto de cosas en sustituto y vendidos no cambiaron}

    proc vender(inout s: Stock, in p: Producto, in c: int)
        requiere {p âˆˆ s.minimo âˆ§ cantDisponibles(p,s) >= c} 
        asegura  {setKey(old(s).vendidos,p,old(s).vendidos-c) == s.vendidos}
        asegura  {El resto de cosas en sustituto y comprados no cambian}

    proc pocoStock(in s: Stock) : conj<Producto>
        asegura  {(âˆ€ p: Producto)(p âˆˆ s.minimo â‡’L 
                    ((s.minimo[p] > cantDisponibles(p,s) âˆ§ Â¬p âˆˆ s.sustituto)
                    âˆ¨ (p âˆˆ s.sustituto â‡’L s.sustituto[p][2] + cantDisponibles(p,s) < s.minimo[p])) â‡’
                        p âˆˆ res)}

    aux cantDisponibles(p: Producto, s: Stock) : int = 
        s.comprados[p] - s.vendidos[p];


} //No me cierra
